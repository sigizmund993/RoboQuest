<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="utf-8">
    <link rel="icon" type="image/png" href="https://img.icons8.com/fluency/48/000000/python.png">
    <title>Z-IDE Pro</title>
    <script src="js/blockly.min.js"></script>
    <script src="js/python_compressed.js"></script>
    <!-- <script src="js/blocks_compressed.js"></script> -->
    <script src="js/ru.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code&family=Inter:wght@400;600&display=swap"
        rel="stylesheet">
    <style>
        :root {
            --bg: #0d1117;
            --panel: #161b22;
            --acc: #58a6ff;
            --brd: #30363d;
            --green: #238636;
        }

        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            background: var(--bg);
            color: #c9d1d9;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        header {
            padding: 10px 20px;
            background: var(--panel);
            border-bottom: 1px solid var(--brd);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .main {
            display: flex;
            flex: 1;
            padding: 10px;
            gap: 10px;
            overflow: hidden;
        }

        #blocklyDiv {
            flex: 2;
            border-radius: 8px;
            border: 1px solid var(--brd);
        }




        .btns {
            display: flex;
            gap: 8px;
        }

        button {
            background: #21262d;
            color: #c9d1d9;
            border: 1px solid var(--brd);
            padding: 8px 14px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
        }

        button:hover {
            background: #30363d;
            border-color: #8b949e;
        }

        button.primary {
            background: var(--green);
            color: white;
            border: none;
        }

        #status {
            font-size: 11px;
            color: #8b949e;
        }
    </style>
</head>

<body>

    <header>
        <div style="display:flex; align-items:center; gap:15px;">
            <span style="color:var(--acc); font-weight:bold; font-size:18px;">ULTIMATE PATRIOTIK IDE</span>
            <div id="status">● Ожидание...</div>
        </div>
        <div class="btns">
            <button onclick="saveBlocks()">Сохранить проект</button>
            <button onclick="loadBlocks()">Открыть проект</button>
            <button id="btnBind">Привязать .py файл</button>
            <button class="primary" onclick="runOnPc()">ЗАПУСТИТЬ</button>
        </div>
    </header>

    <div class="main">
        <div id="blocklyDiv"></div>
    </div>

    <xml id="toolbox" style="display: none">
        <category name="Логика" colour="#5b80a5">
            <block type="controls_if"></block>
            <block type="logic_compare"></block>
            <block type="logic_operation"></block>
            <block type="logic_no"></block>
            <block type="controls_repeat_ext">
                <value name="TIMES">
                    <block type="math_number">
                        <field name="NUM">10</field>
                    </block>
                </value>
            </block>
            <block type="controls_whileUntil"></block>
            <block type="controls_for"></block>
            <block type="math_number"></block>
            <block type="math_arithmetic"></block>
        </category>
        <category name="Текст" colour="#5ba58c">
            <block type="text"></block>
            <block type="text_join"></block>
            <block type="text_append">
                <value name="TEXT">
                    <shadow type="text"></shadow>
                </value>
            </block>
            <block type="text_length"></block>
            <block type="text_isEmpty"></block>
            <block type="text_indexOf"></block>
            <block type="text_charAt"></block>
        </category>
        <category name="Переменные" colour="#a55b80" custom="VARIABLE"></category>
        <category name="Функции" colour="#995ba5" custom="PROCEDURE"></category>
        <category name="Все остальное" colour="#0d8d94">
            <block type="create_var"></block>
            <block type="create_point"></block>
            <block type="point_arithmetic"></block>
            <block type="point_scale"></block>
            <block type="point_get"></block>
            <block type="dist"></block>
            <block type="line_intersect"></block>
            <block type="closest_point_on_line"></block>
            <block type="robot_get_pos"></block>
            <block type="ball"></block>
            <block type="old_ball_pos"></block>
            <block type="ball_moves"></block>
            <block type="ally_goal_center"></block>
            <block type="ally_goal_up"></block>
            <block type="ally_goal_down"></block>
            <block type="enemy_goal_center"></block>
            <block type="enemy_goal_up"></block>
            <block type="enemy_goal_down"></block>
            <block type="def_point_1"></block>
            <block type="def_point_2"></block>
            <!-- <block type="atk_point_1"></block>
            <block type="atk_point_2"></block> -->
            <block type="is_ball_in_zone"></block>
            <block type="strategy_wrapper"></block>
            <block type="kick"></block>
            <block type="go"></block>
        </category>

    </xml>

    <script>
        let fileHandle;
        const statusEl = document.getElementById('status');


        Blockly.Blocks['logic_no'] = {
            init: function () {
                this.appendDummyInput().appendField("не");
                this.appendValueInput("stat").setCheck("Boolean");
                this.setInputsInline(true); this.setOutput(true, "Boolean"); this.setColour("#5b0669");
            }
        };
        Blockly.Python.forBlock['logic_no'] = function (block) {
            const stat = Blockly.Python.valueToCode(block, 'stat', Blockly.Python.ORDER_ATOMIC);
            return [`not ${stat}`, Blockly.Python.ORDER_ATOMIC];
        };

        Blockly.Blocks['create_var'] = {
            init: function () {
                this.appendDummyInput().appendField("объявить переменную");
                this.appendValueInput("var_name").setCheck("String");
                this.setInputsInline(true); this.setPreviousStatement(true); this.setNextStatement(true); this.setColour("#695506");
            }
        };
        Blockly.Python.forBlock['create_var'] = function (block) {
            const name = Blockly.Python.valueToCode(block, 'var_name', Blockly.Python.ORDER_ATOMIC);
            return 'global ' + name + "\n"
        };

        Blockly.Blocks['robot_get_pos'] = {
            init: function () {
                this.appendDummyInput().appendField("положение робота номер");
                this.appendValueInput("id").setCheck("Number");
                this.setOutput(true, "Point"); this.setColour("#5b0669");
            }
        };
        Blockly.Python.forBlock['robot_get_pos'] = function (block) {
            const id = Blockly.Python.valueToCode(block, 'id', Blockly.Python.ORDER_ATOMIC);
            return [`field.allies[${id}].get_pos()`, Blockly.Python.ORDER_ATOMIC];
        };

        Blockly.Blocks['ball'] = {
            init: function () {
                this.appendDummyInput().appendField("мяч");
                this.setInputsInline(true); this.setOutput(true, "Point"); this.setColour("#5b0669");
            }
        };
        Blockly.Python.forBlock['ball'] = function (block) {
            return [`field.ball.get_pos()`, Blockly.Python.ORDER_ATOMIC];
        };

        Blockly.Blocks['old_ball_pos'] = {
            init: function () {
                this.appendDummyInput().appendField("старая позиция мяча");
                this.setInputsInline(true); this.setOutput(true, "Point"); this.setColour("#5b0669");
            }
        };
        Blockly.Python.forBlock['old_ball_pos'] = function (block) {
            return [`field.ball_start_point`, Blockly.Python.ORDER_ATOMIC];
        };
        Blockly.Blocks['ball_moves'] = {
            init: function () {
                this.appendDummyInput().appendField("мяч двигается");
                this.setInputsInline(true); this.setOutput(true, "Boolean"); this.setColour("#5b0669");
            }
        };
        Blockly.Python.forBlock['ball_moves'] = function (block) {
            return [`field.is_ball_moves()`, Blockly.Python.ORDER_ATOMIC];
        };

        Blockly.Blocks['ally_goal_center'] = {
            init: function () {
                this.appendDummyInput().appendField("центр своих ворот");
                this.setInputsInline(true); this.setOutput(true, "Point"); this.setColour("#5b0669");
            }
        };
        Blockly.Python.forBlock['ally_goal_center'] = function (block) {
            return [`field.ally_goal.center`, Blockly.Python.ORDER_ATOMIC];
        };

        Blockly.Blocks['def_point_1'] = {
            init: function () {
                this.appendDummyInput().appendField("точка линии защиты 1");
                this.setInputsInline(true); this.setOutput(true, "Point"); this.setColour("#5b0669");
            }
        };
        Blockly.Python.forBlock['def_point_1'] = function (block) {
            return [`aux.Point(0,-500)`, Blockly.Python.ORDER_ATOMIC];
        };

        Blockly.Blocks['def_point_2'] = {
            init: function () {
                this.appendDummyInput().appendField("точка линии защиты 2");
                this.setInputsInline(true); this.setOutput(true, "Point"); this.setColour("#5b0669");
            }
        };
        Blockly.Python.forBlock['def_point_2'] = function (block) {
            return [`aux.Point(300,-700)`, Blockly.Python.ORDER_ATOMIC];
        };

        Blockly.Blocks['atk_point_1'] = {
            init: function () {
                this.appendDummyInput().appendField("точка линии атаки 1");
                this.setInputsInline(true); this.setOutput(true, "Point"); this.setColour("#5b0669");
            }
        };
        Blockly.Python.forBlock['def_point_1'] = function (block) {
            return [`aux.Point(800, 500)`, Blockly.Python.ORDER_ATOMIC];
        };
        Blockly.Blocks['atk_point_2'] = {
            init: function () {
                this.appendDummyInput().appendField("точка линии атаки 2");
                this.setInputsInline(true); this.setOutput(true, "Point"); this.setColour("#5b0669");
            }
        };
        Blockly.Python.forBlock['def_point_2'] = function (block) {
            return [`aux.Point(300, 800)`, Blockly.Python.ORDER_ATOMIC];
        };
        Blockly.Blocks['ally_goal_up'] = {
            init: function () {
                this.appendDummyInput().appendField("верх своих ворот");
                this.setInputsInline(true); this.setOutput(true, "Point"); this.setColour("#5b0669");
            }
        };
        Blockly.Python.forBlock['ally_goal_up'] = function (block) {
            return [`field.ally_goal.up`, Blockly.Python.ORDER_ATOMIC];
        };

        Blockly.Blocks['ally_goal_down'] = {
            init: function () {
                this.appendDummyInput().appendField("низ своих ворот");
                this.setInputsInline(true); this.setOutput(true, "Point"); this.setColour("#5b0669");
            }
        };
        Blockly.Python.forBlock['ally_goal_down'] = function (block) {
            return [`field.ally_goal.down`, Blockly.Python.ORDER_ATOMIC];
        };


        Blockly.Blocks['enemy_goal_center'] = {
            init: function () {
                this.appendDummyInput().appendField("центр вражеских ворот");
                this.setInputsInline(true); this.setOutput(true, "Point"); this.setColour("#5b0669");
            }
        };
        Blockly.Python.forBlock['enemy_goal_center'] = function (block) {
            return [`field.enemy_goal.center`, Blockly.Python.ORDER_ATOMIC];
        };

        Blockly.Blocks['enemy_goal_up'] = {
            init: function () {
                this.appendDummyInput().appendField("верх вражеских ворот");
                this.setInputsInline(true); this.setOutput(true, "Point"); this.setColour("#5b0669");
            }
        };
        Blockly.Python.forBlock['enemy_goal_up'] = function (block) {
            return [`field.enemy_goal.up`, Blockly.Python.ORDER_ATOMIC];
        };

        Blockly.Blocks['enemy_goal_down'] = {
            init: function () {
                this.appendDummyInput().appendField("низ вражеских ворот");
                this.setInputsInline(true); this.setOutput(true, "Point"); this.setColour("#5b0669");
            }
        };
        Blockly.Python.forBlock['enemy_goal_down'] = function (block) {
            return [`field.enemy_goal.down`, Blockly.Python.ORDER_ATOMIC];
        };




        Blockly.Blocks['create_point'] = {
            init: function () {
                this.appendDummyInput().appendField("точка(");
                this.appendValueInput("X").setCheck("Number");
                this.appendDummyInput().appendField(",");
                this.appendValueInput("Y").setCheck("Number");
                this.appendDummyInput().appendField(")");
                this.setInputsInline(true); this.setOutput(true, "Point"); this.setColour("#0d8d94");
            }
        };
        Blockly.Python.forBlock['create_point'] = function (block) {
            const x = Blockly.Python.valueToCode(block, 'X', Blockly.Python.ORDER_ATOMIC) || '0';
            const y = Blockly.Python.valueToCode(block, 'Y', Blockly.Python.ORDER_ATOMIC) || '0';
            return [`aux.Point(${x}, ${y})`, Blockly.Python.ORDER_ATOMIC];
        };

        Blockly.Blocks['point_arithmetic'] = {
            init: function () {
                this.appendValueInput("A").setCheck("Point");
                this.appendDummyInput().appendField(new Blockly.FieldDropdown([["+", "ADD"], ["-", "SUB"]]), "OP");
                this.appendValueInput("B").setCheck("Point");
                this.setInputsInline(true); this.setOutput(true, "Point"); this.setColour("#0d8d94");
            }
        };
        Blockly.Python.forBlock['point_arithmetic'] = function (block) {
            const a = Blockly.Python.valueToCode(block, 'A', Blockly.Python.ORDER_ATOMIC) || 'aux.Point(0,0)';
            const b = Blockly.Python.valueToCode(block, 'B', Blockly.Python.ORDER_ATOMIC) || 'aux.Point(0,0)';
            const op = block.getFieldValue('OP') === 'ADD' ? '+' : '-';
            return [`${a} ${op} ${b}`, Blockly.Python.ORDER_ATOMIC];
        };



        Blockly.Blocks['line_intersect'] = {
            init: function () {
                this.appendDummyInput().appendField("Пересечение прямых");
                this.appendValueInput("line11").setCheck("Point");
                this.appendValueInput("line12").setCheck("Point");
                this.appendValueInput("line21").setCheck("Point");
                this.appendValueInput("line22").setCheck("Point");
                this.appendDummyInput().appendField(new Blockly.FieldDropdown([["Отрезок", "S"], ["Линия", "L"], ["Луч", "R"]]), "OP1");
                this.appendDummyInput().appendField(new Blockly.FieldDropdown([["Отрезок", "S"], ["Линия", "L"], ["Луч", "R"]]), "OP2");

                this.setInputsInline(true); this.setOutput(true, "Point"); this.setColour("#0d8d94");
            }
        };
        Blockly.Python.forBlock['line_intersect'] = function (block) {
            const line11 = Blockly.Python.valueToCode(block, 'line11', Blockly.Python.ORDER_ATOMIC) || 'aux.Point(0,0)';
            const line12 = Blockly.Python.valueToCode(block, 'line12', Blockly.Python.ORDER_ATOMIC) || 'aux.Point(0,0)';
            const line21 = Blockly.Python.valueToCode(block, 'line21', Blockly.Python.ORDER_ATOMIC) || 'aux.Point(0,0)';
            const line22 = Blockly.Python.valueToCode(block, 'line22', Blockly.Python.ORDER_ATOMIC) || 'aux.Point(0,0)';

            const op1 = block.getFieldValue('OP1')
            const op2 = block.getFieldValue('OP2')

            return [`aux.get_line_intersection(${line11} if not ${line11} is None else field.ball.get_pos(),${line12} if not ${line12} is None else field.ball.get_pos(),${line21} if not ${line21} is None else field.ball.get_pos(),${line22} if not ${line22} is None else field.ball.get_pos(),"${op1}${op1}") if not aux.get_line_intersection(${line11} if not ${line11} is None else field.ball.get_pos(),${line12} if not ${line12} is None else field.ball.get_pos(),${line21} if not ${line21} is None else field.ball.get_pos(),${line22} if not ${line22} is None else field.ball.get_pos(),"${op1}${op1}") is None else field.ally_goal.center`, Blockly.Python.ORDER_ATOMIC];
        };

        Blockly.Blocks['closest_point_on_line'] = {
            init: function () {
                this.appendDummyInput().appendField("ближайшая точка на линии");
                this.appendValueInput("line1").setCheck("Point");
                this.appendValueInput("line2").setCheck("Point");
                this.appendDummyInput().appendField(new Blockly.FieldDropdown([["Отрезок", "S"], ["Линия", "L"], ["Луч", "R"]]), "OP");

                this.setInputsInline(true); this.setOutput(true, "Point"); this.setColour("#0d8d94");
            }
        };
        Blockly.Python.forBlock['closest_point_on_line'] = function (block) {
            const line1 = Blockly.Python.valueToCode(block, 'line1', Blockly.Python.ORDER_ATOMIC) || 'aux.Point(0,0)';
            const line2 = Blockly.Python.valueToCode(block, 'line2', Blockly.Python.ORDER_ATOMIC) || 'aux.Point(0,0)';

            const op = block.getFieldValue('OP')

            return [`aux.closest_point_on_line(${line1},${line2},"${op1}")`, Blockly.Python.ORDER_ATOMIC];
        };
        Blockly.Blocks['point_scale'] = {
            init: function () {
                this.appendValueInput("P").setCheck("Point");
                this.appendDummyInput().appendField(new Blockly.FieldDropdown([["*", "MUL"], ["/", "DIV"]]), "OP");
                this.appendValueInput("N").setCheck("Number");
                this.setInputsInline(true); this.setOutput(true, "Point"); this.setColour("#0d8d94");
            }
        };
        Blockly.Python.forBlock['point_scale'] = function (block) {
            const p = Blockly.Python.valueToCode(block, 'P', Blockly.Python.ORDER_ATOMIC) || 'aux.Point(0,0)';
            const n = Blockly.Python.valueToCode(block, 'N', Blockly.Python.ORDER_ATOMIC) || '1';
            const op = block.getFieldValue('OP') === 'MUL' ? '*' : '/';
            return [`${p} ${op} ${n}`, Blockly.Python.ORDER_ATOMIC];
        };

        Blockly.Blocks['point_get'] = {
            init: function () {
                this.appendValueInput("P").setCheck("Point");
                this.appendDummyInput().appendField(".").appendField(new Blockly.FieldDropdown([["x", "X"], ["y", "Y"]]), "COORD");
                this.setOutput(true, "Number"); this.setColour("#0d8d94");
            }
        };
        Blockly.Python.forBlock['point_get'] = function (block) {
            const p = Blockly.Python.valueToCode(block, 'P', Blockly.Python.ORDER_ATOMIC) || 'aux.Point(0,0)';
            const coord = block.getFieldValue('COORD').toLowerCase();
            return [`${p}.${coord}`, Blockly.Python.ORDER_ATOMIC];
        };

        Blockly.Blocks['dist'] = {
            init: function () {
                this.appendDummyInput().appendField("расстояние между");
                this.appendValueInput("P1").setCheck("Point");
                this.appendDummyInput().appendField("и");
                this.appendValueInput("P2").setCheck("Point");
                this.setOutput(true, "Number"); this.setColour("#0d8d94");
            }
        };
        Blockly.Python.forBlock['dist'] = function (block) {
            const p1 = Blockly.Python.valueToCode(block, 'P1', Blockly.Python.ORDER_ATOMIC) || 'aux.Point(0,0)';
            const p2 = Blockly.Python.valueToCode(block, 'P2', Blockly.Python.ORDER_ATOMIC) || 'aux.Point(0,0)';
            return [`aux.dist(${p1},${p2})`, Blockly.Python.ORDER_ATOMIC];
        };

        Blockly.Blocks['kick'] = {
            init: function () {
                this.appendValueInput("id").setCheck("Number").appendField("робот номер");
                this.appendValueInput("POINT").setCheck("Point").appendField("бей в");
                this.setInputsInline(true); this.setPreviousStatement(true); this.setNextStatement(true); this.setColour("#695506");
            }
        };
        Blockly.Python.forBlock['kick'] = function (block) {
            const id = Blockly.Python.valueToCode(block, 'id', Blockly.Python.ORDER_ATOMIC) || '0';
            const pt = Blockly.Python.valueToCode(block, 'POINT', Blockly.Python.ORDER_ATOMIC) || 'aux.Point(0,0)';
            return 'actions[' + id + '] = Actions.Kick( ' + pt + ')\n';
        };

        Blockly.Blocks['go'] = {
            init: function () {
                this.appendValueInput("id").setCheck("Number").appendField("робот номер");
                this.appendValueInput("POINT").setCheck("Point").appendField("едь в");
                this.setInputsInline(true); this.setPreviousStatement(true); this.setNextStatement(true); this.setColour("#695506");
            }
        };
        Blockly.Python.forBlock['go'] = function (block) {
            const id = Blockly.Python.valueToCode(block, 'id', Blockly.Python.ORDER_ATOMIC) || '0';
            const pt = Blockly.Python.valueToCode(block, 'POINT', Blockly.Python.ORDER_ATOMIC) || 'aux.Point(0,0)';
            return 'actions[' + id + '] = Actions.GoToPoint( ' + pt + ',aux.angle_to_point(field.allies[' + id + '].get_pos(),field.ball.get_pos()))\n';

        };

        Blockly.Blocks['strategy_wrapper'] = {
            init: function () {
                this.appendDummyInput().appendField("главный цикл программы");
                this.appendStatementInput("STACK").setCheck(null);
                this.setColour("#995ba5");
                this.setTooltip("Поместите команды внутрь этого блока");
            }
        };
        Blockly.Python.forBlock['strategy_wrapper'] = function (block) {
            const branch = Blockly.Python.statementToCode(block, 'STACK');
            const code = branch || Blockly.Python.INDENT + 'pass\n';
            return 'def debug(self: Strategy, field: fld.Field, actions: list[Action]) -> None:\n' + code;
        };
        const workspace = Blockly.inject('blocklyDiv', {
            toolbox: document.getElementById('toolbox'),
            theme: Blockly.Theme.defineTheme('dark', {
                'base': Blockly.Themes.Classic,
                'componentStyles': { 'workspaceBackgroundColour': '#0d1117', 'toolboxBackgroundColour': '#161b22', 'toolboxTextColour': '#c9d1d9', 'flyoutBackgroundColour': '#0d1117' }
            }),
            grid: { spacing: 20, length: 3, colour: '#21262d', snap: true }
        });

        Blockly.Blocks['is_ball_in_zone'] = {
            init: function () {
                this.appendDummyInput().appendField("мяч в зоне");
                this.setInputsInline(true); this.setOutput(true, "Boolean"); this.setColour("#5b0669");
            }
        };
        Blockly.Python.forBlock['is_ball_in_zone'] = function (block) {
            return [`aux.is_point_inside_poly(field.ball.get_pos(),field.ally_goal_center.big_hull)`, Blockly.Python.ORDER_ATOMIC];
        };

        const pyHeader = "# mypy: ignore-errors\nfrom bridge import const\nfrom bridge.auxiliary import aux, fld, rbt\nfrom bridge.const import State as GameStates\nfrom bridge.router.base_actions import Action, Actions, KickActions\nfrom bridge.strategy import attack_roles, defense_roles, goalk_func, ref_states, tests, attacker_func\nfrom bridge.strategy.strategy import Strategy\n";
        //"def debug(self: Strategy, field: fld.Field, actions: list[Action]) -> None:\n"
        const pyEnder = "\nStrategy.debug = debug"
        async function update() {
            const code = pyHeader + Blockly.Python.workspaceToCode(workspace) + pyEnder;
            // document.getElementById('codeOutput').innerText = code;
            if (fileHandle) {
                try {
                    const writable = await fileHandle.createWritable();
                    await writable.write(code);
                    await writable.close();
                } catch (e) { }
            }
        }
        workspace.addChangeListener(update);
        function saveBlocks() {
            const data = JSON.stringify(Blockly.serialization.workspaces.save(workspace));
            const blob = new Blob([data], { type: 'application/json' });
            const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'project.json'; a.click();
        }
        function loadBlocks() {
            const input = document.createElement('input'); input.type = 'file';
            input.onchange = e => {
                const reader = new FileReader();
                reader.onload = ev => Blockly.serialization.workspaces.load(JSON.parse(ev.target.result), workspace);
                reader.readAsText(e.target.files[0]);
            };
            input.click();
        }
        document.getElementById('btnBind').onclick = async () => {
            [fileHandle] = await window.showOpenFilePicker();
            statusEl.innerText = "● Файл привязан"; statusEl.style.color = "#3fb950";
            update();
        };
        function runOnPc() { fetch('/run').catch(() => alert("Ошибка сервера")); }
    </script>
</body>

</html>